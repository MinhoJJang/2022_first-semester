# GraphData

각 n에 대하여, 각 Sort 함수를 100번 실행한 시간의 평균이다. level에 따라서는 수행시간이 비슷하기 때문에, 랜덤배열, 오름차순 배열, 내림차순 배열에 대하여 비교해보자.

# 1. Comparison of Time Complexity by Array Alignment Differences

각 Sort에 사용된 unSorted.dat의 정렬 방식에 따라 Sort 알고리즘들의 성능 차이를 비교해보자. 각 order에 사용된 배열은 double타입 배열이다. 각 크기에 따른 배열을 생성하고, 그 배열을 각 Sort마다 10번씩 정렬한 후 그 평균값을 데이터로 사용하였다.

## random order

| n / ms | BubbleSort | InsertionSort | SelectionSort | HeapSort | QuickSort | MergeSort |
| ------ | ---------- | ------------- | ------------- | -------- | --------- | --------- |
| 10     | 0          | 0             | 0             | 0        | 0         | 0         |
| 100    | 22         | 15            | 12            | 8        | 15        | 7         |
| 1000   | 1459       | 577           | 1022          | 119      | 39        | 124       |
| 3000   | 12705      | 4925          | 8811          | 403      | 253       | 465       |
| 5000   | 36636      | 13161         | 24699         | 916      | 471       | 748       |
| 7000   | 75581      | 25732         | 46764         | 1207     | 801       | 991       |
| 10000  | 159556     | 59141         | 94234         | 1462     | 1001      | 1507      |

```
SpLine({(10, 0), (100, 17), (1000, 1459), (3000, 12705), (5000, 36636),(7000, 75581), (10000, 159556)})
SpLine({(10, 0), (100, 6), (1000, 577), (3000, 4925), (5000, 13161),(7000, 25732),(10000, 59141)})
SpLine({(10, 0), (100, 10), (1000, 1022), (3000, 8811), (5000, 24699),(7000, 46764),(10000, 94234)})
SpLine({(10, 0), (100, 5), (1000, 119),(3000, 403), (5000, 916),(7000, 1207), (10000, 1462)})
SpLine({(10, 0), (100, 3), (1000, 39), (3000, 253), (5000, 471),(7000, 801), (10000, 1001)})
SpLine({(10, 0), (100, 7), (1000, 124), (3000, 465), (5000, 748),(7000, 991), (10000, 1507)})
```

[RandomOrder](https://www.geogebra.org/calculator/tcmnrj7r)
![RandomOrder](./image/RandomOrder_Performance%20Comparison.png)

> 랜덤 배열일 경우, 모든 경우에서 QuickSort가 가장 빠른 정렬속도를 보여준다.

## descending order

| n / ms | BubbleSort | InsertionSort | SelectionSort | HeapSort | QuickSort | MergeSort |
| ------ | ---------- | ------------- | ------------- | -------- | --------- | --------- |
| 10     | 0          | 0             | 0             | 0        | 0         | 0         |
| 100    | 17         | 6             | 10            | 5        | 3         | 7         |
| 1000   | 1816       | 1170          | 1187          | 147      | 1128      | 96        |
| 3000   | 17794      | 11487         | 9160          | 474      | 10180     | 245       |
| 5000   | 46304      | 29239         | 26661         | 726      | 27238     | 384       |
| 7000   | 86569      | 58820         | 51767         | 1001     | 54802     | 718       |
| 10000  | 175521     | 117726        | 100447        | 1499     | 104215    | 917       |

```
SpLine({(10, 0), (100, 17), (1000, 1816), (3000, 17794), (5000, 46304),(7000, 86569), (10000, 175521)})
SpLine({(10, 0), (100, 6), (1000, 1170), (3000, 11487), (5000, 29239),(7000, 58820),(10000, 117726)})
SpLine({(10, 0), (100, 10), (1000, 1187), (3000, 9160), (5000, 26661),(7000, 51767),(10000, 100447)})
SpLine({(10, 0), (100, 5), (1000, 147), (3000, 474), (5000, 726), (7000, 1001), (10000, 1499)})
SpLine({(10, 0), (100, 3), (1000, 1128), (3000, 10180), (5000, 27238), (7000, 54802), (10000, 104215)})
SpLine({(10, 0), (100, 7), (1000, 96), (3000, 245), (5000, 384),(7000, 718), (10000, 917)})
```

[DescendingOrder](https://www.geogebra.org/graphing/a5khmk5c)
![DescendingOrder](./image/DescendingOrder_Performance%20Comparison.png)

> 내림차순 배열을 정렬할 때 QuickSort의 경우 Insertion과 Selection 과 성능이 크게 차이나지 않는다. 그 이유는 QuickSort의 로직에 있다. 랜덤 배열일 경우 pivot으로 나누어지는 배열의 크기가 서로 크게 차이나지 않지만 정렬된 배열일 경우 pivot이 극단적인 위치에 존재하기 때문에 분할 정복을 사용하는 QuickSort는 사실상 분할을 하지 않는 것과 다름없으므로 Selection, Insertion과 비슷한 성능을 보이게 된다.

## ascending order

| n / ms | BubbleSort | InsertionSort | SelectionSort | HeapSort | QuickSort | MergeSort |
| ------ | ---------- | ------------- | ------------- | -------- | --------- | --------- |
| 10     | 0          | 0             | 0             | 0        | 0         | 0         |
| 100    | 13         | 0             | 11            | 6        | 13        | 7         |
| 1000   | 1270       | 4             | 987           | 112      | 1090      | 90        |
| 3000   | 9411       | 11            | 9560          | 368      | 9187      | 280       |
| 5000   | 25925      | 18            | 26509         | 708      | 25333     | 395       |
| 7000   | 49603      | 27            | 48890         | 886      | 51073     | 734       |
| 10000  | 98957      | 36            | 108586        | 1429     | 105246    | 1057      |

```
SpLine({(10, 0), (100, 13), (1000, 1270), (3000, 9411), (5000, 25925),(7000, 49603), (10000, 98957)})
SpLine({(10, 0), (100, 0), (1000, 4), (3000, 11), (5000, 18),(7000, 27),(10000, 36)})
SpLine({(10, 0), (100, 11), (1000, 987), (3000, 9560), (5000, 26509),(7000, 48890),(10000, 108586)})
SpLine({(10, 0), (100, 6), (1000, 112), (3000, 368), (5000, 708), (7000, 886), (10000, 1429)})
SpLine({(10, 0), (100, 13), (1000, 1090), (3000, 9187), (5000, 25333), (7000, 51073), (10000, 105246)})
SpLine({(10, 0), (100, 7), (1000, 90), (3000, 280), (5000, 395), (7000, 734), (10000, 1057)})
```

[AscendingOrder](https://www.geogebra.org/graphing/d2m5ytdm)
![AscendingOrder](./image/AscendingOrder_Performance%20Comparison.png)

> 오름차순 정렬 상태일 경우, InsertionSort 로직 상 단순히 값 비교만 하고, 값의 복사나 이동이 전혀 이뤄지지 않기 때문에 시간복잡도가 O(n)인 최적의 알고리즘이 된다. QuickSort는 역시나 극단적으로 정렬된 배열을 정렬할 때는 분할 정복이 전혀 이루어지지 않는 것과 같기 때문에 Selection, Bubble과 유사한 시간복잡도를 갖는다.
